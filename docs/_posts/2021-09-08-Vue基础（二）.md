---
layout: post
title:  "vue基础（二）"
date:   2021-09-08
categories: Vue 
tags: Vue  
---
* content
{:toc}
## 一、组件简介

​	Component 组件是可复用的Vue实例，且带有一个名字，可以把组件作为自定义元素来使用

​	将项目中重复出现的页面结构定义为Vue的一个组件实例，或将特殊功能封装成组件

## 二、定义组件

​	组件分类：

- 全局组件，在所有Vue实例中都可以使用
- 局部组件，只能在构建组件的 Vue实例的容器范围内使用

### 1. 全局组件

​	全局组件的定义，通过全局方法 `Vue.component()`来定义

​	两种写法

- 方式1：`Vue.component(组件名, 组件构造器)`

  先创建组件构造器，然后由组件构造器创建组件

- 方式2：`Vue.component(组件名, 选项对象)`

  直接创建组件，传入一个选项对象

  本质上还是自动调用 Vue.extend 先创建组件构造器

​    **注：组件必须在一个已存在的Vue实例中使用，不能在页面独立使用和存在**

### 2. 局部组件

​	局部组件的定义，依赖于某个Vue实例，通过选项 `components:{}` 来定义

​	用法：

```js
new Vue({
  components:{
    "component-a":Vue.extend({ /* ... */ }),
    "component-b":{ /* ... */ }
  }
})
```

## 三、组件间数据传递 

### 1. 组件间的关系   

​	页面组件的关系结构，是一个由许多组件构成的树状结构，组件间存在着两种关系：父子关系、非父子关系

​	**默认情况下，每个组件实例都是独立的，组件间无法直接访问数据，因此需要进行组件间的数据传递，也称为组件间的通信**

![image-20190804002126441](assets/image-20190804002126441.png)



### 2. 父子组件间的数据传递

#### 2.1 父向子传递数据

​	技术：属性绑定+数据拦截

​	步骤：

1. 父组件在调用子组件时，以属性绑定的方式将要传递的数据绑定在子组件标签上       
2. 在子组件对象中，使用props选项声明获取的数据，进行绑定属性的拦截，即接收来自父组件的数据

#### 2.2 子向父传递数据

​	技术：事件监听+事件触发

​	步骤：

1. 父组件在调用子组件时，监听子组件触发的自定义事件，并在父组件中定义回调方法，用来接收数据
2. 在子组件中使用vm.$emit(事件名,数据)触发自定义事件

​    补充：

- 子组件向父组件传递数据是不具有响应式的，即子组件数据发生变化时并不会主动触发$emit更新父组件中数据
- 可以监视子组件数据的变化，当数据发生变化时手动触发$emit更新父组件中数据

#### 2.3  其他

​	祖先组件向后代组件传递数据，也称为注入依赖或依赖注入：

- 使用provide/inject实现，由provide的组件传递给inject的组件
- 在祖先组件中使用`provide`选项提供一个可注入到其后代的数据对象
- 在后代组件中使用`inject`选项注入一个要接收数据的字符串数组

​    父组件向子组件传递样式：

- 为子组件绑定样式属性（style、class），则样式属性会绑定子组件的**根标签**上
- 在复用组件时，可以通过该方式实现组件样式的不同

   子组件调用父组件中的方法：

- 如果是子组件的非根标签调用，则在子组件上绑定自定义事件，然后在子组件的非根标签中使用$emit触发调用
- 如果是子组件的根标签调用，则在子组件上绑定原生事件，并使用事件绑定修饰符`.native`进行修饰，监听组件根元素的原生事件

### 3. 非父子组件间的数据传递

​	非父子组件间的通信，通过**中央事件总线 Event Bus** 来实现，也称为事件中心

​	其实就是使用一个可以在所有组件中访问的Vue实例，用它来监听事件和触发事件

```javascript
vm.$emit(事件名, 数据);  // 触发事件
vm.$on(事件名, data => {});  // 监听事件   
vm.$root // 获取Root根组件
```

​	注：new Vue()创建的组件一般作为整个项目的启动组件和容器组件，所以该组件称为Root根组件

### 4. 组件的生命周期执行顺序

​	当项目由多个组件构成时，各个组件的生命周期执行具有先后关系

- beforeMount及之前的生命周期阶段，根据页面中组件的定义顺序，由外而内，由上而下，依次执行
- 当所有beforeMount生命周期函数执行完成后，根据页面中组件的定义顺序，由内而外，由上而下，依次执行mounted函数
- **总结：所有的beforeMount函数都优先于所有mounted函数执行**

   非父子组件间进行数据传递时：

- `vm.$on`一定要优先于`vm.$emit`执行
- 如果要实现自动传递数据，需要将`vm.$on`定义在beforeMount中，将`vm.$emit`定义在mounted中

## 四、组件间双向数据共享

### 1. 单向数据流

​	对于父向子的数据传递，props是单向绑定的

- 当父组件中数据变化时，将自动传递给子组件，但是反过来不行
- 不允许子组件直接修改父组件中的数据
- props拦截的变量都是只读的，不允许修改

​    如果子组件想修改数据并同步更新到父组件，有两种方式：

- 方式1：使用.sync修饰符+显式触发一个更新事件

  `vm.$emit('update:属性',数据)`     

- 方式2：将父组件中的数据包装成对象，然后在子组件中修改对象的属性

  因为对象是引用类型，指向同一个内存空间

### 2. 独立响应式对象

​	对于组件间的数据共享，也可以使用**Vue2.6.0**新增的`Vue.observable(object)`

+ `Vue.observable` 可以让一个对象变成可响应的，返回一个独立的响应式对象
+ 该响应式对象可以在任意组件的计算属性内使用，并且会在数据发生改变时触发相应的组件更新
+ 实际上，此时就是将其作为组件间数据状态存储的一个容器

​    补充：可结合Vue的混入 (mixin) 技术，对组件中的复用代码进行统一配置，所有配置的内容都将“混合”进入组件中

- 全局混入，使用`Vue.mixin(options)`
- 局部混入，依赖于某个Vue实例的`mixins` 选项

## 五、内置全局组件

​	Vue提供了全局的内置组件，这些组件主要完成的都是功能封装

### 1. 动态组件

​	多个组件使用同一个挂载点，然后动态地在它们之间切换，称为动态组件

​	用法：`<component :is=""></component>`

### 2. 缓存组件

​	缓存非活动的组件，可以保留组件状态，避免重新渲染，默认每次都会销毁非活动组件并重新创建

​	一般会结合动态组件使用，用于缓存非活动的组件实例，避免组件的重复创建和删除，提高性能

​	用法：`<keep-alive>动态组件</keep-alive>`

​	注：`<keep-alive>`是一个抽象组件，它自身不会渲染为一个 DOM 元素，也不会出现在组件链中

### 3. 分发组件

​	实现内容的分发，可以在定义组件时指定插槽位置，调用组件时提供要替换插槽位置的内容

- 在开发组件时，如果组件模板中部分内容暂时不确定，则可以通过`<slot>`插槽定义页面占位
- 当调用组件时，再定义对应的内容，会自动替换到插槽位置

  用法：`<slot></slot>`

  具名插槽：为插槽指定名称，根据插槽名称进行内容分发

- 在定义插槽时，在slot标签上通过name属性为插槽指定名称
- 在提供插槽内容时，通过为template标签指定v-slot指令，并以指令参数表示插槽名称

  插槽数据作用域：让插槽内容能够访问子组件中的数据，通过作用域插槽控制内容分发时变量的取值范围

- 在定义插槽时，在slot标签上通过v-bind进行数据绑定
- 在提供插槽内容时，通过v-slot指令接收绑定的数据，获取的是一个自定义对象

### 4. 过渡组件

​	Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。

​	本质上还是使用CSS3动画：transition、animation，但是操作更简单

​	用法：`<transition>动画元素</transition>` 或 `<transition-group>`

- 将要执行动画的元素包含在transition组件内

- 自定义过渡类名

  enter-class="进入前的样式" 

  enter-active-class="进入过程中的动画样式"

  enter-to-class="进入后的样式"

  leave-class="离开前的样式"

  leave-active-class="离开过程中的动画样式"

  leave-to-class="离开后的样式"

- 钩子函数

  @before-enter
  @enter
  @after-enter
  @before-leave
  @leave
  @after-leave

